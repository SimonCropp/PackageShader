<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShaderAssembly>$(MSBuildThisFileDirectory)..\task\PackageShader.MsBuild.dll</ShaderAssembly>
    <ShaderAssembly Condition="!Exists($(ShaderAssembly))">$(MSBuildThisFileDirectory)..\bin\$(Configuration)\PackageShader.MsBuild.dll</ShaderAssembly>

    <!-- Register our target for NuGet pack to include shaded assemblies -->
    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);_IncludeShadedInPackage</TargetsForTfmSpecificContentInPackage>
  </PropertyGroup>

  <UsingTask
    TaskName="PackageShader.ShadeTask"
    AssemblyFile="$(ShaderAssembly)" />

  <UsingTask
    TaskName="PackageShader.DepsJsonPatcherTask"
    AssemblyFile="$(ShaderAssembly)" />

  <UsingTask
    TaskName="PackageShader.NupkgPatcherTask"
    AssemblyFile="$(ShaderAssembly)" />

  <!-- Target 1: Collect PackageReference and ProjectReference items with Shade="true" -->
  <Target Name="_CollectShadedReferences"
          BeforeTargets="ShadeTarget"
          Condition="'@(PackageReference)' != '' Or '@(ProjectReference)' != ''">
    <ItemGroup>
      <_ShadedPackageNames Include="@(PackageReference->'%(Identity)')"
                            Condition="'%(PackageReference.Shade)' == 'true'" />
      <_ShadedProjectFiles Include="@(ProjectReference->'%(FullPath)')"
                            Condition="'%(ProjectReference.Shade)' == 'true'" />
    </ItemGroup>
    <PropertyGroup>
      <_ShadedPackageNamesJoined>;@(_ShadedPackageNames);</_ShadedPackageNamesJoined>
      <_ShadedProjectFilesJoined>;@(_ShadedProjectFiles);</_ShadedProjectFilesJoined>
    </PropertyGroup>
  </Target>

  <!-- Target 2: Match shaded references to ReferenceCopyLocalPaths -->
  <Target Name="_MatchShadedAssemblies"
          AfterTargets="_CollectShadedReferences"
          BeforeTargets="ShadeTarget"
          Condition="'$(_ShadedPackageNamesJoined)' != ';;' Or '$(_ShadedProjectFilesJoined)' != ';;'">
    <ItemGroup>
      <!-- Match PackageReference by NuGetPackageId metadata -->
      <_AssembliesToShade Include="@(ReferenceCopyLocalPaths)"
        Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != '' And $(_ShadedPackageNamesJoined.Contains(';%(ReferenceCopyLocalPaths.NuGetPackageId);'))" />
      <!-- Match ProjectReference by MSBuildSourceProjectFile metadata -->
      <_AssembliesToShade Include="@(ReferenceCopyLocalPaths)"
        Condition="'%(ReferenceCopyLocalPaths.MSBuildSourceProjectFile)' != '' And $(_ShadedProjectFilesJoined.Contains(';%(ReferenceCopyLocalPaths.MSBuildSourceProjectFile);'))" />
    </ItemGroup>
  </Target>

  <!-- Main shading target -->
  <Target
    Name="ShadeTarget"
    AfterTargets="AfterCompile"
    DependsOnTargets="_CollectShadedReferences;_MatchShadedAssemblies"
    Condition="'@(IntermediateAssembly)' != '' And $(DesignTimeBuild) != true">
    <!-- Condition on _AssembliesToShade moved here because DependsOnTargets runs after target condition is evaluated -->
    <PackageShader.ShadeTask
      Condition="'@(_AssembliesToShade)' != ''"
      IntermediateAssembly="@(IntermediateAssembly)"
      IntermediateDirectory="$(ProjectDir)$(IntermediateOutputPath)"
      SignAssembly="$(SignAssembly)"
      Internalize="$(Shader_Internalize)"
      AssembliesToShade="@(_AssembliesToShade)"
      SolutionDir="$(SolutionDir)"
      ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)"
      AssemblyOriginatorKeyFile="$(AssemblyOriginatorKeyFile)">

      <Output
        TaskParameter="CopyLocalPathsToAdd"
        ItemName="CopyLocalPathsToAdd" />
      <Output
        TaskParameter="CopyLocalPathsToRemove"
        ItemName="CopyLocalPathsToRemove" />
      <Output
        TaskParameter="ShadedNameMappings"
        ItemName="_ShadedNameMappings" />

    </PackageShader.ShadeTask>

    <ItemGroup Condition="'@(_AssembliesToShade)' != ''">
      <ReferenceCopyLocalPaths Remove="@(CopyLocalPathsToRemove)" />
      <ReferenceCopyLocalPaths Include="@(CopyLocalPathsToAdd)" />
      <!-- Mark shaded assemblies for inclusion in NuGet package (only those with assembly name prefix) -->
      <_ShadedDllsToAdd Include="@(CopyLocalPathsToAdd)"
                        Condition="'%(Extension)' == '.dll' AND $([System.String]::Copy('%(Filename)').StartsWith('$(AssemblyName).'))" />
    </ItemGroup>

    <!-- Write shaded DLL list to a file for use during pack -->
    <PropertyGroup Condition="'@(_ShadedDllsToAdd)' != ''">
      <_ShadedDllsListFile>$(IntermediateOutputPath)PackageShader.ShadedDlls.txt</_ShadedDllsListFile>
    </PropertyGroup>
    <WriteLinesToFile
      Condition="'@(_ShadedDllsToAdd)' != ''"
      File="$(_ShadedDllsListFile)"
      Lines="@(_ShadedDllsToAdd)"
      Overwrite="true"
      WriteOnlyWhenDifferent="true" />

    <!-- Write shaded package names to a file for use during pack (for nupkg patching) -->
    <!-- This is needed because conditional PackageReferences (e.g. Condition="'$(TargetFramework)' == 'netstandard2.0'")
         are not visible at the outer build level during Pack in multi-targeted projects -->
    <PropertyGroup Condition="'@(_ShadedPackageNames)' != ''">
      <_ShadedPackageNamesListFile>$(IntermediateOutputPath)PackageShader.ShadedPackageNames.txt</_ShadedPackageNamesListFile>
    </PropertyGroup>
    <WriteLinesToFile
      Condition="'@(_ShadedPackageNames)' != ''"
      File="$(_ShadedPackageNamesListFile)"
      Lines="@(_ShadedPackageNames)"
      Overwrite="true"
      WriteOnlyWhenDifferent="true" />
  </Target>

  <!-- Target 4: Include shaded assemblies in NuGet package -->
  <!-- This target is called via TargetsForTfmSpecificContentInPackage during pack -->
  <Target Name="_IncludeShadedInPackage">
    <!-- Try to auto-detect the primary assembly's package path from TfmSpecificPackageFile -->
    <ItemGroup>
      <_PrimaryOutputPackageFile Include="@(TfmSpecificPackageFile)"
        Condition="$([System.IO.Path]::GetFileName('%(Identity)')) == '$(TargetFileName)'" />
    </ItemGroup>

    <!-- Extract the package path (without the filename) by transforming the item and reading it back -->
    <ItemGroup Condition="'@(_PrimaryOutputPackageFile)' != ''">
      <_PackagePathExtracted Include="%(_PrimaryOutputPackageFile.PackagePath)" />
    </ItemGroup>

    <PropertyGroup>
      <!-- Use auto-detected path if found -->
      <_ShadedPackagePath Condition="'@(_PackagePathExtracted)' != ''">@(_PackagePathExtracted)</_ShadedPackagePath>
      <!-- Otherwise use explicit override -->
      <_ShadedPackagePath Condition="'$(_ShadedPackagePath)' == '' And '$(ShadedAssembliesPackagePath)' != ''">$(ShadedAssembliesPackagePath)</_ShadedPackagePath>
      <!-- Finally fall back to default -->
      <_ShadedPackagePath Condition="'$(_ShadedPackagePath)' == ''">lib\$(TargetFramework)</_ShadedPackagePath>
      <_ShadedDllsListFile>$(IntermediateOutputPath)PackageShader.ShadedDlls.txt</_ShadedDllsListFile>
    </PropertyGroup>

    <!--
      Read the list of shaded assemblies from a file written during build.
      This file contains the CopyLocalPathsToAdd output from ShadeTask, which persists
      between build and pack phases, allowing this to work with 'dotnet pack' without rebuilding.
    -->
    <ReadLinesFromFile File="$(_ShadedDllsListFile)" Condition="Exists('$(_ShadedDllsListFile)')">
      <Output TaskParameter="Lines" ItemName="_ShadedDllsFromFile" />
    </ReadLinesFromFile>

    <ItemGroup Condition="'@(_ShadedDllsFromFile)' != ''">
      <TfmSpecificPackageFile Include="@(_ShadedDllsFromFile)">
        <PackagePath>$(_ShadedPackagePath)</PackagePath>
        <Pack>true</Pack>
      </TfmSpecificPackageFile>
    </ItemGroup>
  </Target>

  <!-- Target 5: Patch deps.json to use shaded assembly names -->
  <Target Name="_PatchDepsJson"
          AfterTargets="GenerateBuildDependencyFile"
          Condition="'@(_ShadedNameMappings)' != ''">
    <PropertyGroup>
      <_DepsJsonPath>$(ProjectDir)$(OutputPath)$(AssemblyName).deps.json</_DepsJsonPath>
    </PropertyGroup>
    <PackageShader.DepsJsonPatcherTask
      DepsJsonPath="$(_DepsJsonPath)"
      ShadedNameMappings="@(_ShadedNameMappings)" />
  </Target>

  <!-- Target 6: Patch nupkg to remove shaded dependencies -->
  <!-- NuGet reads dependencies from project.assets.json (created at restore time), not live PackageReference items.
       So we patch the nupkg after it's created to remove shaded package dependencies.

       For multi-targeted projects, conditional PackageReferences (e.g. Condition="'$(TargetFramework)' == 'netstandard2.0'")
       are not visible at the outer build level. So we read shaded package names from files written during inner builds. -->
  <Target Name="_PatchNupkgRemoveShadedDependencies"
          AfterTargets="Pack">

    <!-- For single-targeted projects, collect shaded package names directly -->
    <ItemGroup Condition="'$(TargetFramework)' != ''">
      <_ShadedPackageNamesForNupkg Include="@(PackageReference->'%(Identity)')"
                                    Condition="'%(PackageReference.Shade)' == 'true'" />
    </ItemGroup>

    <!-- For multi-targeted projects, read shaded package names from files written during inner builds -->
    <ItemGroup Condition="'$(TargetFrameworks)' != ''">
      <_TargetFrameworkList Include="$(TargetFrameworks)" />
    </ItemGroup>

    <!-- Find all ShadedPackageNames.txt files from each TFM's intermediate directory -->
    <ItemGroup Condition="'$(TargetFrameworks)' != ''">
      <_ShadedPackageNamesFiles Include="$(BaseIntermediateOutputPath)$(Configuration)\*\PackageShader.ShadedPackageNames.txt" />
    </ItemGroup>

    <!-- Read shaded package names from all TFM files -->
    <ReadLinesFromFile
      Condition="'@(_ShadedPackageNamesFiles)' != ''"
      File="%(_ShadedPackageNamesFiles.Identity)">
      <Output TaskParameter="Lines" ItemName="_ShadedPackageNamesForNupkg" />
    </ReadLinesFromFile>

    <!-- Construct the nupkg path (ensure trailing slash on PackageOutputPath) -->
    <PropertyGroup>
      <_PackageOutputPathWithSlash Condition="!$(PackageOutputPath.EndsWith('\')) And !$(PackageOutputPath.EndsWith('/'))">$(PackageOutputPath)\</_PackageOutputPathWithSlash>
      <_PackageOutputPathWithSlash Condition="$(PackageOutputPath.EndsWith('\')) Or $(PackageOutputPath.EndsWith('/'))">$(PackageOutputPath)</_PackageOutputPathWithSlash>
      <_NupkgFilePath>$(_PackageOutputPathWithSlash)$(PackageId).$(PackageVersion).nupkg</_NupkgFilePath>
    </PropertyGroup>

    <!-- Patch the nupkg to remove shaded dependencies -->
    <PackageShader.NupkgPatcherTask
      Condition="'@(_ShadedPackageNamesForNupkg)' != '' And Exists('$(_NupkgFilePath)')"
      NupkgPath="$(_NupkgFilePath)"
      ShadedPackageNames="@(_ShadedPackageNamesForNupkg)" />
  </Target>
</Project>
