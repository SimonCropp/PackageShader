<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShaderAssembly>$(MSBuildThisFileDirectory)..\task\PackageShader.MsBuild.dll</ShaderAssembly>
    <ShaderAssembly Condition="!Exists($(ShaderAssembly))">$(MSBuildThisFileDirectory)..\bin\$(Configuration)\PackageShader.MsBuild.dll</ShaderAssembly>

    <!-- Register our target for NuGet pack to include shaded assemblies -->
    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);_IncludeShadedInPackage</TargetsForTfmSpecificContentInPackage>
  </PropertyGroup>

  <UsingTask
    TaskName="PackageShader.ShadeTask"
    AssemblyFile="$(ShaderAssembly)" />

  <UsingTask
    TaskName="PackageShader.DepsJsonPatcherTask"
    AssemblyFile="$(ShaderAssembly)" />

  <!-- Target 1: Collect PackageReference and ProjectReference items with Shade="true" -->
  <Target Name="_CollectShadedReferences"
          BeforeTargets="ShadeTarget"
          Condition="'@(PackageReference)' != '' Or '@(ProjectReference)' != ''">
    <ItemGroup>
      <_ShadedPackageNames Include="@(PackageReference->'%(Identity)')"
                            Condition="'%(PackageReference.Shade)' == 'true'" />
      <_ShadedProjectFiles Include="@(ProjectReference->'%(FullPath)')"
                            Condition="'%(ProjectReference.Shade)' == 'true'" />
    </ItemGroup>
    <PropertyGroup>
      <_ShadedPackageNamesJoined>;@(_ShadedPackageNames);</_ShadedPackageNamesJoined>
      <_ShadedProjectFilesJoined>;@(_ShadedProjectFiles);</_ShadedProjectFilesJoined>
    </PropertyGroup>
  </Target>

  <!-- Target 2: Match shaded references to ReferenceCopyLocalPaths -->
  <Target Name="_MatchShadedAssemblies"
          AfterTargets="_CollectShadedReferences"
          BeforeTargets="ShadeTarget"
          Condition="'$(_ShadedPackageNamesJoined)' != ';;' Or '$(_ShadedProjectFilesJoined)' != ';;'">
    <ItemGroup>
      <!-- Match PackageReference by NuGetPackageId metadata -->
      <_AssembliesToShade Include="@(ReferenceCopyLocalPaths)"
        Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != '' And $(_ShadedPackageNamesJoined.Contains(';%(ReferenceCopyLocalPaths.NuGetPackageId);'))" />
      <!-- Match ProjectReference by MSBuildSourceProjectFile metadata -->
      <_AssembliesToShade Include="@(ReferenceCopyLocalPaths)"
        Condition="'%(ReferenceCopyLocalPaths.MSBuildSourceProjectFile)' != '' And $(_ShadedProjectFilesJoined.Contains(';%(ReferenceCopyLocalPaths.MSBuildSourceProjectFile);'))" />
    </ItemGroup>
  </Target>

  <!-- Target 3: Mark shaded packages as PrivateAssets=all for NuGet pack -->
  <Target Name="_ExcludeShadedFromNuGetDeps"
          BeforeTargets="_GetPackageFiles;_WalkEachTargetPerFramework;GenerateNuspec"
          AfterTargets="CollectPackageReferences"
          Condition="'@(PackageReference)' != ''">
    <ItemGroup>
      <PackageReference Condition="'%(PackageReference.Shade)' == 'true'">
        <PrivateAssets>all</PrivateAssets>
      </PackageReference>
    </ItemGroup>
  </Target>

  <!-- Main shading target -->
  <Target
    Name="ShadeTarget"
    AfterTargets="AfterCompile"
    DependsOnTargets="_CollectShadedReferences;_MatchShadedAssemblies"
    Condition="'@(IntermediateAssembly)' != '' And $(DesignTimeBuild) != true">
    <!-- Condition on _AssembliesToShade moved here because DependsOnTargets runs after target condition is evaluated -->
    <PackageShader.ShadeTask
      Condition="'@(_AssembliesToShade)' != ''"
      IntermediateAssembly="@(IntermediateAssembly)"
      IntermediateDirectory="$(ProjectDir)$(IntermediateOutputPath)"
      SignAssembly="$(SignAssembly)"
      Internalize="$(Shader_Internalize)"
      AssembliesToShade="@(_AssembliesToShade)"
      SolutionDir="$(SolutionDir)"
      ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)"
      AssemblyOriginatorKeyFile="$(AssemblyOriginatorKeyFile)">

      <Output
        TaskParameter="CopyLocalPathsToAdd"
        ItemName="CopyLocalPathsToAdd" />
      <Output
        TaskParameter="CopyLocalPathsToRemove"
        ItemName="CopyLocalPathsToRemove" />
      <Output
        TaskParameter="ShadedNameMappings"
        ItemName="_ShadedNameMappings" />

    </PackageShader.ShadeTask>

    <ItemGroup Condition="'@(_AssembliesToShade)' != ''">
      <ReferenceCopyLocalPaths Remove="@(CopyLocalPathsToRemove)" />
      <ReferenceCopyLocalPaths Include="@(CopyLocalPathsToAdd)" />
      <!-- Mark shaded assemblies for inclusion in NuGet package (only those with assembly name prefix) -->
      <_ShadedDllsToAdd Include="@(CopyLocalPathsToAdd)"
                        Condition="'%(Extension)' == '.dll' AND $([System.String]::Copy('%(Filename)').StartsWith('$(AssemblyName).'))" />
    </ItemGroup>

    <!-- Write shaded DLL list to a file for use during pack -->
    <PropertyGroup Condition="'@(_ShadedDllsToAdd)' != ''">
      <_ShadedDllsListFile>$(IntermediateOutputPath)PackageShader.ShadedDlls.txt</_ShadedDllsListFile>
    </PropertyGroup>
    <WriteLinesToFile
      Condition="'@(_ShadedDllsToAdd)' != ''"
      File="$(_ShadedDllsListFile)"
      Lines="@(_ShadedDllsToAdd)"
      Overwrite="true"
      WriteOnlyWhenDifferent="true" />
  </Target>

  <!-- Target 4: Include shaded assemblies in NuGet package -->
  <!-- This target is called via TargetsForTfmSpecificContentInPackage during pack -->
  <Target Name="_IncludeShadedInPackage">
    <!-- Try to auto-detect the primary assembly's package path from TfmSpecificPackageFile -->
    <ItemGroup>
      <_PrimaryOutputPackageFile Include="@(TfmSpecificPackageFile)"
        Condition="$([System.IO.Path]::GetFileName('%(Identity)')) == '$(TargetFileName)'" />
    </ItemGroup>

    <!-- Extract the package path (without the filename) by transforming the item and reading it back -->
    <ItemGroup Condition="'@(_PrimaryOutputPackageFile)' != ''">
      <_PackagePathExtracted Include="%(_PrimaryOutputPackageFile.PackagePath)" />
    </ItemGroup>

    <PropertyGroup>
      <!-- Use auto-detected path if found -->
      <_ShadedPackagePath Condition="'@(_PackagePathExtracted)' != ''">@(_PackagePathExtracted)</_ShadedPackagePath>
      <!-- Otherwise use explicit override -->
      <_ShadedPackagePath Condition="'$(_ShadedPackagePath)' == '' And '$(ShadedAssembliesPackagePath)' != ''">$(ShadedAssembliesPackagePath)</_ShadedPackagePath>
      <!-- Finally fall back to default -->
      <_ShadedPackagePath Condition="'$(_ShadedPackagePath)' == ''">lib\$(TargetFramework)</_ShadedPackagePath>
      <_ShadedDllsListFile>$(IntermediateOutputPath)PackageShader.ShadedDlls.txt</_ShadedDllsListFile>
    </PropertyGroup>

    <!--
      Read the list of shaded assemblies from a file written during build.
      This file contains the CopyLocalPathsToAdd output from ShadeTask, which persists
      between build and pack phases, allowing this to work with 'dotnet pack' without rebuilding.
    -->
    <ReadLinesFromFile File="$(_ShadedDllsListFile)" Condition="Exists('$(_ShadedDllsListFile)')">
      <Output TaskParameter="Lines" ItemName="_ShadedDllsFromFile" />
    </ReadLinesFromFile>

    <ItemGroup Condition="'@(_ShadedDllsFromFile)' != ''">
      <TfmSpecificPackageFile Include="@(_ShadedDllsFromFile)">
        <PackagePath>$(_ShadedPackagePath)</PackagePath>
        <Pack>true</Pack>
      </TfmSpecificPackageFile>
    </ItemGroup>
  </Target>

  <!-- Target 5: Patch deps.json to use shaded assembly names -->
  <Target Name="_PatchDepsJson"
          AfterTargets="GenerateBuildDependencyFile"
          Condition="'@(_ShadedNameMappings)' != ''">
    <PropertyGroup>
      <_DepsJsonPath>$(ProjectDir)$(OutputPath)$(AssemblyName).deps.json</_DepsJsonPath>
    </PropertyGroup>
    <PackageShader.DepsJsonPatcherTask
      DepsJsonPath="$(_DepsJsonPath)"
      ShadedNameMappings="@(_ShadedNameMappings)" />
  </Target>
</Project>
